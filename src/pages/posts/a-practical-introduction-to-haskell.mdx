---
title: A Practical Introduction to Haskell
keywords: haskell, functional programming
description: WIP.
url: https://parkerlandon.com/posts/a-practical-introduction-to-haskell
ogImageUrl: https://adoring-jackson-1187ff.netlify.app/.netlify/functions/gen-opengraph-image?title=A%20Practical%20Introduction%20to%20Haskell&tags=haskell,functional%20programming
postnum: 4
---

Following my previous article introducing parsing in Haskell (read here, [A Practical Introduction to Parsing in Haskell](/posts/a-practical-introduction-to-parsing-in-haskell)), I have decided to write an introduction to the Haskell programming language and pure functional programming more broadly.

> TODO: Mention reason for writing (ivory tower, functional programming historically restricted to academia, not as popular as other paradigms) (Why no one uses functional programming)

In writing this article, I aim to follow that same "practical" style; my focus is on Haskell and functional programming as tools for development, so I'll avoid as much as possible the weeds of academic theory and jargon. I'll begin by introducing functional programming and its status among other paradigms, then dive into Haskell as a programming language that embraces the functional programming style.

### Object-Oriented Programming

If you've written code in a contemporary programming language, you're probably familiar with "object-oriented programming." Since its popularity surge among academics and software developers in the 1990s, the object-oriented paradigm has dominated mainstream computer programming, existing as the core of ubiquitous programming languages like Java and C++.[^1] Object-oriented programming entails encapsulating data within "objects" possessing properties and behaviors defined by the object's "class." In other words, classes act as the blueprints for objects: they define the type, behavior, and properties that an instantiated object of that class will have.


```ts
// The Rectangle Class: a "blueprint" of every Rectangle object
class Rectangle {
  private _length: number;
  private _width: number;

  constructor(length: number, width: number) {
    this._length = length;
    this._width = width;
  }

  area() {
    return this._length * this._width;
  }
}

// myRectangle: an instantiated object of the Rectangle class
const myRectangle = new Rectangle(4, 3);
myRectangle.area(); // 12!
```

A central aspect of the object-oriented paradigm is encoding hierarchical relationships between classes via "inheritance" and "composition." For example, one could encode within their program that a `Rectangle` _is a_ `Square` by creating a new `class Square` from which `Rectangle` inherits behaviors and properties. But why go through this effort of encoding classes, behaviors, properties, relationships, etc.?

### Imperative Programming and Side Effects

Another significant feature of mainstream object-oriented programming languages is their traditionally "imperative" style. Imperative programming entails describing program behavior by encoding a sequence of state transitions from an initial state to a final state.[^2] In other words, each operation in an imperative program may have the _side effect_ of mutating the overall state of the system. If intentional or "correct," these side effects incrementally transition the system's state towards the desired final state. However, an unintentional or "incorrect" side effect may cause the system to produce an unexpected result.

A goal of object-oriented programming (i.e., using classes, behaviors, properties, relationships, etc.) is to _encapsulate_ these state updates by containing them within objects and abstracting over them with a defined interface. Interacting with the data encapsulated by `myRectangle`, for example, is managed by the `Rectangle` class and limited by its provided interface (viz., its `constructor` and the `area` method). This way, state updates are more controlled, and unintended results are more easily identified as occurring within a class instead of "somewhere in the system."

Still, state transitions represent only one kind of side effect. Programs may also

- print text
- read data from a file
- query a database
- execute other programs
- send emails
- launch missiles[^2]

Typically, the imperative style allows these side effects to occur anywhere in the program, and often without any indication or warning that they occur.

```ts
// Our `main` function does not indicate that this program launches missiles.
function main() {
    console.log("Hello world!");
    foo();
}

...

function foo() {
    // Indeed, this program launches missiles.
    launchMissiles();
}
```

In general, there exists a tradeoff between correctness and writability. While the liberty to produce side effects without restriction may feel convenient when writing a program, it introduces more possibilities for creating incorrect programs with unexpected results.

### Functional Programming and Purity

In contrast to imperative programming, the functional programming (FP) paradigm places a greater emphasis on correctness. According to the FP style, a program is a function defined in terms of other functions; programs are compositions of functions. Rather than performing computations as sequences of state transitions, functional computations are carried out by applying functions to arguments. Of course, imperative programming languages often provide the ability to construct and apply functions, too, but the functional programming style distinguishes itself by promoting _purity_.

A function is said to be _pure_ if its execution produces no side effects and its output depends on nothing besides its input. In other words, the result of a pure function is wholly determined by its input; it will always produce the same output given the same input. Thus, the behavior of a pure function is captured entirely by it's definition: its result neither mutates nor is influenced by any program state.[^2] In this way, contrasting with the "statefulness" of imperative programming, functional programming is said to be "stateless."

> Give an example of a pure function versus an impure function

The upshot of purity is that it eliminates the possibility of rogue side effects by doing away with side effects altogether. While this limitation may seem severe, it affords several benefits that promote correctness. For example, a functional program is easy to reason about. Because a pure function's behavior is captured entirely by its definition, there is never a concern for how a function operates in the broader context of a stateful program. For the same reasons, functional programs tend to be trivial to test. While a test of an impure function might first require arranging the appropriate preconditions (a generally laborious task within an imperative program), testing a pure function simply requires providing it with the appropriate inputs and asserting about its outputs.

>**Also mention parallelization** (Why Parallel Functional Programming Matters, How Functional Programming mattered)

Still, it may seem that there exists a fatal problem with the purity restriction: a program composed solely of pure functions is useless. Necessary operations like receiving inputs and displaying outputs are kinds of side effects, so they cannot be performed in a pure context. Fortunately, Haskell facilitates producing side effects through the use of _monads_, which encode impure functions and create a boundary distinguishing effectful operations from pure ones. This feature of Haskell is an aspect of its rich type system, which I will introduce now.

### Haskell Types

Haskell is a statically-typed programming language, meaning that the type of each value is known at compile time and that programs with type errors will fail to compile. Static typing is another limitation like purity that aims to promote correctness. Although it cannot eliminate all unexpected or undesired behaviors, static type checking prevents the programmer from introducing a certain class of errors, like that which arises from adding numbers to boolean values.[^3] While there exists disagreement about the cost to convenience of static type checking and the extent to which it ensures program safety,[^4] I aim to illustrate how Haskell's robust type system promotes correctness while still enabling flexibility.

In Haskell, every value has an associated type. We can explicitly declare the type of a value with the `::` symbol.

```hs
number :: Int
listOfNumbers :: [Int]
numberTuple :: (Int, Int)
```

Functions are values, too, and therefore also have types. The `->` symbol is used to denote the type of a function mapping.

```hs
length :: [Int] -> Int
```

The statement above declares that the function `length` maps a list of integers `[Int]` to a single integer `Int`. The semantics of `length` is intuitive: given a list of integers, return the number of elements. However, notice that `length` is not very flexible: we couldn't use it to find the length of a list of characters, for example. Fortunately, Haskell provides _polymorphic_ types, which enables type declarations to include _type variables_ that can be instantiated to any type.[^2] For example, the type `[a]` includes the type variable `a` and denotes a list of any type. Using polymorphic types, the type of `length` can be rewritten to be more reusable.

```hs
length :: [a] -> Int
```

We can apply a function `f` to an argument `a` with the syntax `f a`. Thus, we can compute the length of a `list :: [Int]` with `length list`.

```hs
listLength :: Int
listLength = length list
```

What about functions with two or more parameters? We could define a trivial function `add`, for example, that returns the sum of two `Int` arguments. A first pass at the type declaration of `add` might group the two parameters into a tuple:

```hs
add :: (Int, Int) -> Int
add (x, y) = x + y
````

Then, to apply `add` as declared to the values `1` and `2`, we would write `add (1,2)`.

Now, consider the following new definition of `add`:

```hs
add :: Int -> Int -> Int
add x y = x + y
```

The `->` symbol is right-associative, so `Int -> Int -> Int` implicitly means `Int -> (Int -> Int)` and can be read as "a function that maps an `Int` to a function that maps an `Int` to an `Int`". This style of writing a function with two or more parameters as a function mapping a single argument to a function with a single parameter is called _currying_.[^5]

With our new, curried type definition, we can apply `add` to `1` and `2` by writing `add 1 2`. Function application is left-associative, so `add 1 2` is equivalent to `(add 1) 2`. From this formulation, it's clear that we could extract `(add 1)` into its own function `increment`!

```hs
increment :: Int -> Int
increment = add 1

increment 2 -- this is the same as (add 1) 2!
```

Currying lets us easily build specific operations from general ones, making our functions more extensible and robust. Thus, currying is the default for function definitions in Haskell.

So far, we've defined functions using equations (e.g., `add x y = x + y`). Alternatively, we can define functions with lambda expressions, which have arguments and a body like any other function but do not have a name. For example, we can define a new function `add2` to be the lambda expression `\x y -> x + y`. Just like `add`, `add2` takes two arguments, `x` and `y`, and returns their sum.

```hs
add2 :: Int -> Int -> Int
add2 = \x y -> x + y
````

### Typeclasses

Can we make our `add` function more flexible? Currently it only works for adding integers, but it would be convenient if `add` supported all kinds of numbers.

A first pass at implementing a more reusable `add` function would be to use polymorphic types in the type declaration to support all types.

```hs
add :: a -> a -> a
add x y = x + y
```

However, this code won't compile because the `+` operator is not defined for all types: the Haskell compiler wouldn't know how to perform `add True False`, for example. Thus, `add` should only support the _class_ of types for which `+` is defined. Indeed, Haskell provides _type classes_ that enable us to overload operations for different types and categorize types according to the operations they support.

A `class` declaration describes a new typeclass according to its operations and their type signatures. A simple typeclass is the built-in `Eq` typeclass, which says that a type `a` is an instance of `Eq` if it defines the equality operator `==` with type `a -> a -> Bool`.[^6]

```hs
class Eq a where
  (==) :: a -> a -> Bool
```

For the purpose of extending our `add` function, we're interested in the `Num` typeclass, which generalizes basic numeric operations like `+`.

```hs
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
```

Now we can use the `Num` typeclass as the _context_ of `a` in the type declaration of `add`, restricting the types `add` supports to those that define addition with the `+` operator.[^6]

```hs
add :: (Num a) => a -> a -> a
add a b = a + b
```

### Defining Types

What if we wanted to define our own kind of numeric type, like a type `Complex` to represent complex numbers? We can introduce a new type with the `data` keyword. Before we define `Complex`, consider the following type declaration for `Bool`.

```hs
data Bool = True | False
```

The declaration introduces the type constructor `Bool` along with the values (or _data constructors_) it comprises: `True` and `False`.[^7] Now we can use `Bool` as a type and its values `True` or `False` whenever we expect a `Bool` value.

```hs
not :: Bool -> Bool
not True = False
not False = True
```

The definition of the `not` function above is an example of _pattern matching_ on the values of a type. Haskell allows us to redefine functions for different input patterns. When a function is applied, the pattern on the left-hand side of its equation (e.g., `True` in `not True = False`) is matched against the argument. If the argument aligns with the pattern, the function evaluates and returns the right-hand side of the equation. Otherwise, the argument is matched against the pattern in the next equation, and the process continues until a pattern is matched or all patterns have been tried, in which case an error occurs.[^8]

```hs
result :: Bool
result = not True -- False!
```

The type constructor and corresponding data constructors for `Bool` are nullary: they take no arguments. However, when considering a new type `Complex`, we might expect its data constructor to take two arguments, the first representing the real part and the second representing the imaginary part. Indeed, data constructors can be parameterized; after all, they are _functions_ that produce results of their corresponding type.[^8] For example, the following data declaration for `Complex` introduces a new type `Complex` and a corresponding data constructor `Comp` that takes two `Float` arguments.

```hs
data Complex = Comp Float Float
```

Now, we can define operations on `Complex` values and use the `Comp` constructor whenever we might expect a value of type `Complex`.

```hs
myComplexNumber :: Complex
myComplexNumber = Comp 3 4

magnitude :: Complex -> Float
magnitude (Comp x y) = sqrt (x^2 + y^2)

result :: Float
result = magnitude myComplexNumber -- 5.0
```

Like value constructors, the _type constructors_ in a data declaration can be parameterized to produce polymorphic types.[^7] A notable example of a polymorphic type is `Maybe`, which is declared as follows:

```hs
data Maybe a = Just a | Nothing
```

The `Maybe` _type constructor_ can be applied to any other type `t` to produce a new type, `Maybe t`.[^7] That new type has two _value constructors_, `Just` and `Nothing`, which we might think of as representing success and failure, respectively.[^8] For example, a function `unlock` could return a `Maybe String` value that contains a message if the provided `key` is correct and `Nothing` otherwise.

```hs
unlock :: String -> Maybe String
unlock key = if key == "kitten" then Just "Meow!" else Nothing

test1 = unlock "puppy" -- Nothing
test2 = unlock "kitten" -- Just "Meow!"
```

> Pattern matching, History of Haskell
> The data declaration declares Maybe to be a data type, with two data constructors Nothing and Just. The values of the Maybe type take one of two forms: either Nothing or (Just x). Data constructors can be used both in pattern-matching, to decompose a value of Maybe type, and in an expression, to build a value of Maybe type. Both are illustrated in the definition of mapMaybe. (History of Haskell)

### Declaring Instances

Having defined a new type `Complex` for representing complex numbers, we can now declare it as an instance of the `Num` typeclass. The following _instance_ declaration provides for the `Complex` type an appropriate definition of each operation in the `Num` typeclass, thus declaring that the `Complex` type belongs to `Num`.[^6]

```hs
instance Num Complex where
  (Comp x1 y1) + (Comp x2 y2) = Comp (x1 + x2) (y1 + y2)
  (Comp x1 y1) - (Comp x2 y2) = Comp (x1 - x2) (y1 - y2)
  (Comp x1 y1) * (Comp x2 y2) = Comp (x1 * x2 - y1 * y2) (x1 * y2 + x2 * y1)
  negate (Comp x y) = Comp (negate x) (negate y)
  abs z = Comp (magnitude z) 0
  signum (Comp 0 0) = 0
  signum z@(Comp x y) = Comp (x / r) (y / r)
   where
    r = magnitude z
  fromInteger n = Comp (fromInteger n) 0
```

Now we can use `Complex` values where we expect an instance of `Num`.

```hs
add :: (Num a) => a -> a -> a
...
add (Comp 3 4) (Comp 5 6) -- Comp 8.0 10.0
```

### Built-in Types

So far, we've considered several functions, types, and typeclasses that are built in to Haskell. These base utilities are provided by the _standard prelude_, which is a library file that all Haskell modules import by default.[^7]

Two (previously introduced) built-in _parameterized_ types are list (`[]`) and `Maybe`. The list type, denoted `[a]` or `[] a`, represents a sequence of elements of the same type `a`. The `Maybe` type, `Maybe a`, can be thought of as a result that either fails and is `Nothing` or succeeds and contains a value of type `a` within `Just`.[^7]

Another useful parameterized type is `Either a b`, which is defined as follows.

```hs
data Either a b = Left a | Right b
```

Similar to the `Maybe` type, `Either` encodes two possibilities; however, unlike `Maybe`, both values of `Either` carry some value. `Either String Int`, for example, represents values that contain a `String` (within `Left`) and values that contain an `Int` (within `Right`).

Perhaps the most unique and important parameterized type is `IO a`. As previously mentioned, the Haskell type system enforces purity by distinguishing effectful operations from pure ones. This boundary is constructed largely by the `IO a` type, which represents values whose computation may have demanded some input/output side effect to be produced.[^5] Consider, for example, the type of `getChar`, which reads a character from `stdin`.

```hs
getChar :: IO Char
```

Intuitively, `getChar` produces a `Char` result. However, because it involves the effectful operation of reading from `stdin`, the type of `getChar` is annotated with `IO`.

> can't escape, suggest monad


### Built-in Typeclasses: Functor, Applicative, and Monad

Parameterized types are ubiquitous in Haskell, as they enable us to qualify existing types and express _structure_ or _effects_. The standard prelude provides us with generic operations for working with parameterized types, which are captured in the `Functor`, `Applicative`, and `Monad` typeclasses.

The `Functor` typeclass declares an operation `fmap` that captures the notion of applying an operation to the elements of a structure while preserving that structure's shape.[^9]

```hs
class Functor f where
  fmap :: (a -> b) -> f a -> f b
```

Per the class declaration, a parameterized type `f` is an instance of `Functor` if it provides the operation `fmap` that applies a function `a -> b` to a value `f a` and produces a new value `f b`.

An example of a `Functor` instance is the type `Maybe`, which defines `fmap :: (a -> b) -> Maybe a -> Maybe b` to apply the provided function `a -> b` to the underlying value of a successful result (`Just a`) or propagate a failure (`Nothing`).[^7]

```hs
instance Functor Maybe where
  fmap _ Nothing = Nothing
  fmap g (Just x) = Just (g x)

fmap increment (Just 1) -- Just 2
fmap increment Nothing -- Nothing
```

Similarly, the `Functor` instance `Either` defines `fmap :: (a -> b) -> Either t a -> Either t b` to apply the provided function to the underlying value of a `Right a` result or propagate a `Left t` value.

```hs
instance Functor (Either t) where
  fmap _ (Left x) = Left x
  fmap f (Right y) = Right (f y)

fmap increment (Left 2) -- Left 2
fmap increment (Right 2) -- Right 3
```

Notice, the function `fmap` is restricted to applying a function of a single argument. The `Applicative` typeclass generalizes `Functor` and `fmap` for functions of any number of arguments.

```hs
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
```

The syntax `class Functor f => Applicative f` declares that a parameterized type belongs to `Applicative` if it provides the operations of `Applicative`, `pure` and `<*>`, _and_ is an instance of `Functor`.[^6]. With currying and the `Applicative` operations, we can sequence computations over parameterized types and combine their results.[^9] For example, we can use the `Applicative` operations to add two `Maybe Int` operands, producing `Nothing` if either operand is `Nothing` or a `Just` value otherwise. Similarly, `Applicative` operations on `Either` values will either propagate `Left` values or produce `Right` results.

```hs
pure (+) <*> Just 3 <*> Just 5 -- Just 8
pure (+) <*> Just 4 <*> Nothing -- Nothing

pure (-) <*> Right 3 <*> Right 2 -- Right 1
pure (-) <*> Left 3 <*> Right 2 -- Left 3
```

The `Functor` and `Applicative` typeclasses generalize the application of functions producing pure results to effectful arguments having parameterized types. However, they do not capture the common pattern of applying a function producing an effectful result to an effectful value; this operation is instead captured by `>>=` (pronounced "bind") operator provided by the `Monad` typeclass.[^7]

```hs
class Applicative m => Monad m where
  return :: a -> m b
  (>>=) :: m a -> (a -> m b) -> m b
```

For example, a function `safeSqrt :: Float -> Just Float` could return `Nothing` if the argument is negative and the result of the square root operation otherwise.

```hs
safeSqrt :: Float -> Maybe Float
safeSqrt x = if x < 0 then Nothing else Just (sqrt x)

safeSqrt 16 -- Just 4.0
safeSqrt (-4) -- Nothing
````

Given that `Maybe` is an instance of `Monad`, we can chain `safeSqrt` operations with the `>>=` operator. This way, the square root operation will be repeatedly applied to valid inputs, and `Nothing` results will be propagated for invalid inputs.

```hs
safeSqrt 16 >>= safeSqrt -- Just 2.0
safeSqrt (-4) >>= safeSqrt -- Nothing
```

Now, to write a function `safeSqrtSum` that uses `safeSqrt` to compute $$\sqrt{x} + \sqrt{y}$$, we could chain several `>>=` operators together with lambda expressions and `return` the `Float` result, producing a final `Maybe Float` value.

```hs
safeSqrtSum :: Float -> Float -> Maybe Float
safeSqrtSum x y =
  safeSqrt x >>= \l ->
    safeSqrt y >>= \r ->
      return (l + r)

safeSqrtSum 9 16 -- Just 7.0
safeSqrtSum 4 -1 -- Nothing
```

Haskell provides the `do` syntax to express this common pattern of computation more concisely. The following definition of `safeSqrtSum` is equivalent to the previous.

```hs
safeSqrtSum x y = do
  l <- safeSqrt x
  r <- safeSqrt y
  return (l + r)
```

> io

[^1]: See [The Early History of F#](https://fsharp.org/history/hopl-final/hopl-fsharp.pdf)
[^2]: See [How Functional Programming Mattered](https://academic.oup.com/nsr/article/2/3/349/1427872)
[^3]: See _Types and Programming Languages_ by B.C. Pierce
[^4]: See [Static Typing Where Possible, Dynamic Typing When Needed](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=e670c72afa489ffdfab77852a0c9781e082fc266) and [Scripting: Higher-Level Programming for the 21st Century](https://web.stanford.edu/~ouster/cgi-bin/papers/scripting.pdf)
[^5]: See [A History of Haskell](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf)
[^6]: See [Type Classes in Haskell](https://dl.acm.org/doi/10.1145/227699.227700)
[^7]: See _Programming in Haskell: Second Edition_ by Graham Hutton
[^8]: See [A Gentle Introduction to Haskell](https://cpsc.yale.edu/sites/default/files/files/tr901.pdf)
[^9]: See [Constructing Applicative Functors](https://openaccess.city.ac.uk/id/eprint/1141/1/)

import withLayout from '../../lib/withLayout'
export default withLayout(frontmatter)
