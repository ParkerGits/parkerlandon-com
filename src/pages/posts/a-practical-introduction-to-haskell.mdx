---
title: A Practical Introduction to Haskell
keywords: haskell, functional programming
description:
url: https://parkerlandon.com/a-practical-introduction-to-haskell
ogImageUrl: https://adoring-jackson-1187ff.netlify.app/.netlify/functions/gen-opengraph-image?title=A%20Practical%20Introduction%20to%20Haskell&tags=haskell,functional%20programming
postnum: 4
---

Following my previous article introducing parsing in Haskell (read here, [A Practical Introduction to Parsing in Haskell](/posts/a-practical-introduction-to-parsing-in-haskell)), I have decided to write an introduction to the Haskell programming language and pure functional programming more broadly. In writing this article, I aim to follow that same "practical" style; my focus is on Haskell and functional programming as tools for development, so I'll avoid as much as possible the weeds of academic theory and jargon. I'll begin by introducing functional programming and its status among other paradigms, then dive into Haskell as a programming language that embraces the functional programming style.

### Object-Oriented Programming

If you've written code in a contemporary programming language, you're probably familiar with "object-oriented programming." Since its popularity surge among academics and software developers in the 1990s, the object-oriented paradigm has dominated mainstream computer programming, existing as the core of ubiquitous programming languages like Java and C++.[^1] Object-oriented programming entails encapsulating data within "objects" possessing properties and behaviors defined by the object's "class." In other words, classes act as the blueprints for objects: they define the type, behavior, and properties that an instantiated object of that class will have.


```ts
// The Rectangle Class: a "blueprint" of every Rectangle object
class Rectangle {
  private _length: number;
  private _width: number;

  constructor(length: number, width: number) {
    this._length = length;
    this._width = width;
  }

  area() {
    return this._length * this._width;
  }
}

// myRectangle: an instantiated object of the Rectangle class
const myRectangle = new Rectangle(4, 3);
myRectangle.area(); // 12!
```

A central aspect of the object-oriented paradigm is encoding hierarchical relationships between classes via "inheritance" and "composition." For example, one could encode within their program that a `Rectangle` _is a_ `Square` by creating a new `class Square` from which `Rectangle` inherits behaviors and properties. But why go through this effort of encoding classes, behaviors, properties, relationships, etc.?

### Imperative Programming and Side Effects

Another significant feature of mainstream object-oriented programming languages is their traditionally "imperative" style. Imperative programming entails describing program behavior by encoding a sequence of state transitions from an initial state to a final state.[^2] In other words, each operation in an imperative program may have the _side effect_ of mutating the overall state of the system. If intentional or "correct," these side effects incrementally transition the system's state towards the desired final state. However, an unintentional or "incorrect" side effect may cause the system to produce an unexpected result.

A goal of object-oriented programming (i.e., using classes, behaviors, properties, relationships, etc.) is to _encapsulate_ these state updates by containing them within objects and abstracting over them with a defined interface. Interacting with the data encapsulated by `myRectangle`, for example, is managed by the `Rectangle` class and limited by its provided interface (viz., its `constructor` and the `area` method). This way, state updates are more controlled, and unintended results are more easily identified as occurring within a class instead of "somewhere in the system."

Still, state transitions represent only one kind of side effect. Programs may also print text, execute other programs, send emails, and launch missiles.[^2] Typically, the imperative style allows these side effects to occur anywhere in the program, and often without any indication or warning that they occur.

```ts
// Our `main` function does not indicate that this program launches missiles.
function main() {
    console.log("Hello world!");
    foo();
}

...

function foo() {
    // Indeed, this program launches missiles.
    launchMissiles();
}
```

In general, there exists a tradeoff between correctness and writability. While the liberty to produce side effects without restriction may feel convenient when writing a program, it introduces more possibilities for creating incorrect programs with unexpected results.

### Functional Programming and Purity

In contrast to imperative programming, the functional programming (FP) paradigm places a greater emphasis on correctness. According to the FP style, a program is a function defined in terms of other functions; programs are compositions of functions. Rather than performing computations as sequences of state transitions, functional computations are carried out by applying functions to arguments. Of course, imperative programming languages often provide the ability to construct and apply functions, too, but the functional programming style distinguishes itself by promoting _purity_. A function is said to be _pure_ if its execution produces no side effects and its output depends on nothing besides its input. In other words, the result of a pure function is wholly determined by its input; it will always produce the same output given the same input. Thus, the behavior of a pure function is captured entirely by it's definition: its result neither mutates nor is influenced by any program state.[^2] In this way, contrasting with the "statefulness" of imperative programming, functional programming is said to be "stateless."

The upshot of purity is that it eliminates the possibility of rogue side effects by doing away with side effects altogether. While this limitation may seem severe, it affords several benefits that all promote correctness. For example, a functional program is easy to reason about because a pure function's behavior is captured entirely by its definition. There is never a concern for how a function operates in the broader context of a stateful program because its output depends solely on its input. For these same reasons, pure functions are trivial to test. While a test of an impure function might first require arranging the appropriate preconditions (a generally laborious task within an imperative program), testing a pure function simply requires providing it with the appropriate inputs and asserting about its outputs.

[^1]: See [The Early History of F#](https://fsharp.org/history/hopl-final/hopl-fsharp.pdf)
[^2]: See [How Functional Programming Mattered](https://academic.oup.com/nsr/article/2/3/349/1427872)

import withLayout from '../../lib/withLayout'
export default withLayout(frontmatter)
