---
title: Testing Parsers Thoroughly with Quickcheck
keywords: haskell, quickcheck, parsers, testing, functional programming
description: TODO
url: https://parkerlandon.com/testing-parsers-thoroughly-with-quickcheck
ogImageUrl: https://adoring-jackson-1187ff.netlify.app/.netlify/functions/gen-opengraph-image?title=Parsing%20Chained%20Expressions%2C%20Functionally&tags=haskell%2Cfunctional%20programming
postnum: 3
---

I've been implementing QuickCheck property-based testing for the parser of my command-line JSON processing language, [hson](https://github.com/ParkerGits/hson). Without any additional context, take a look at the following test output:

```txt
*** Failed! Falsified (after 9993 tests and 3 shrinks):
GetExpr
  ( Get
      { object =
          VariableExpr
            ( Variable
                { varName =
                    Token
                      { tokenType = TokenIdentifier
                      , literal = Just leaf
                      , pos = "leaf" (line 0, column 0)
                      }
                }
            )
      , property =
          Token
            { tokenType = TokenIdentifier
            , literal = Just let
            , pos = "a" (line - 2, column 0)
            }
      }
  )
```

If you're unfamiliar with QuickCheck and property-based testing, the following may have crossed your mind:

1. Wow, 9993 tests?
2. What is a shrink?

You might also be wondering, _"What is `GetExpr ...` in the test output?"_ and _"Why did the test fail?"_

Now, allow me to provide some context about these tests.

**Explain property-based testing**

**Explain QuickCheck and how it generates arbitrary inputs**

**Apply explanation to hson and how I've defined arbitrary instances to generate valid parse trees**

**So...**

`GetExpr` and the data that follows it are nodes and values within an hson parse tree.

```hs
parseGet :: HSONParser (Expr -> Expr)
parseGet = do
  dot
  -- identifier fails if the parsed string is a reserved word
  property <- identifier
  return $ \object -> GetExpr Get{object = object, property = property}
```

The failed test also made me realize that the same bug might be occurring for reserved words as properties in object literal expressions like the following:

```ts
{ false: true }
```

Indeed, when I ran this program through my interpreter, I encountered an error.

```txt
(line 1, column 8):
unexpected reserved word "false"
expecting expression
```

And the cause was, again, the use of the `identifier` parser.

```hs
keyValue = do
  k <- try tokenString <|> identifier -- the culprit!
  colon
  v <- expression
  return (k, Just v)
```

So, thanks to the test, I was able to discover two bugs that prevented reserved words to be set and accessed as properties of objects. That's an effective test!

**Talk about writing arbitrary instances**

**Different iterations... for example, starting with all arbitrary expressions, then specifying what kinds of expressions, then specifying precedence**

"Nope, QuickCheck generated an input that should fail, fix the arbitrary instances"

"Oh, that is an input that should pass, fix the Parser"

import withLayout from '../../lib/withLayout'
export default withLayout(frontmatter)
